import discord, os, sys, json, random, logging, requests
from discord.ext import commands
#from replit import db
from discord import Embed, Color
import sqlite3

con = sqlite3.connect('data1.db')
cur = con.cursor()


chatTarL = 2
chatTarH = 5

#db['scores'] = {}

#chatChannels = [670362292659159040, 774408820721844254, 670362865684840449, 670362843467612268, 853439192100110376, 853439192100110376, 853439216834314320]

#db['chatChannels'] = [670362292659159040, 774408820721844254, 670362865684840449, 670362843467612268, 853439192100110376, 853439192100110376, 853439216834314320]
#chatChannels = [853439192100110376, 853439216834314320]

Svalue = {}

def exe_rq(connection, query): #execute and read a query
    cursor = connection.cursor()
    result = None
    try:
        cursor.execute(query)
        result = cursor.fetchall()
        return result
    except Error as e:
        print(f"The error '{e}' occurred")

#Custom checks
def is_it_me(ctx):
    return ctx.message.author.id == 585991293377839114

def addScore(userid, guildid, amount=1):
  try:
    i = db[f's{guildid}']
  except KeyError:
    db[f's{guildid}'] = {}
  #i = db['scores']
  i = db[f's{guildid}']
  #print(i)
  if str(userid) in i:
    if (i[str(userid)] + amount) < 0:
      print('Ignoring Negitive Score. User database has not changed.') 
    else:
      i[str(userid)] =  i[str(userid)] + amount
      print(f'User got {str(amount)} point(s). {userid}')
  else:
    if amount < 0:
      print('Ignoring Negitive Score. User database has not changed.')
    print(f'New user added. {userid}')
    i[str(userid)] = amount
  db[f's{guildid}'] = i
  return str(i[str(userid)])

def checkScore(userid, guildid):
  try:
    i = db[f's{guildid}']
  except KeyError:
    db[f's{guildid}'] = {}
  #i = db['scores']
  i = db[f's{guildid}']
  #i = db['scores']
  #print(i)
  if str(userid) in i:
    #print('User found in db')
    return str(i[str(userid)])
  else:
    print('User not found.')
    return '0'

def MakeLb(guildid):
  #i = db['scores']
  #x = db['scores']
  try:
    i = db[f's{guildid}']
  except KeyError:
    db[f's{guildid}'] = {}
  #i = db['scores']
  i = db[f's{guildid}']
  x = db[f's{guildid}']
  #print(len(x))
  scores = []
  for score in i:
    #print(scores)
    scores.append(i[score])
  scores = sorted(scores, reverse=True)
  #print(scores)
  lbid=list(i)
  #print(lbid)
  for userid in x:
    pmt=0
    x=False
    #print(i[userid])
    while x != True:
      if i[userid] == scores[pmt]:
        lbid[pmt] = userid
        #print(str(lbid[pmt]) + str(i[userid]))
        scores[pmt] = -100
        x = True
      pmt+=1
 #print(lbid)
  return lbid

  

class Sparkle(commands.Cog):
    def __init__(self, bot):
      self.bot = bot

      self.chatA = 0
      self.chatTar = random.randint(chatTarL, chatTarH)
      self.Tmessage = None
      self.Twait = False
      self.chatChannels = db['chatChannels']
      print(self.chatTar + 1)

    #events
    @commands.Cog.listener()
    async def on_ready(self):
      print('sparkles is online')
    
    @commands.Cog.listener()
    async def on_message(self, message):
      #await self.bot.process_commands(message)
      if message.author.id == self.bot.user.id:
        return
      #check if channel is in db
      self.chatChannels = db['chatChannels']
      if message.channel.id in self.chatChannels:
        #print(f'Message seen. {self.chatTar - self.chatA} left!')
        #check if there is a sparkle already spawned
        if self.Twait == False:

          self.chatA += 1
          #check if chat activity is exceeded
          if self.chatA > self.chatTar:
            print('Target Triggered')
            self.Temoji = self.bot.get_emoji(853036933684658176)  
            self.Twait = True  
            self.Tmessage = await message.channel.send('**React for sparkles!**')
            def check(reaction, user):
              print(reaction.emoji)
              print(self.Temoji)
              print(reaction.message.id)
              print(self.Tmessage.id)
              return str(reaction.emoji) == str(self.Temoji) and reaction.message.id == self.Tmessage.id
            print('Sent reaction')
            await self.Tmessage.add_reaction(self.Temoji)
            while True:
              try:
                reaction, user = await self.bot.wait_for('reaction_add', timeout=200.0, check=check)
              except Exception:
                await self.Tmessage.edit(content='This sparkle didn\'t get claimed!', delete_after=5)
                self.Tmessage = None
                self.chatA = 0
                self.Twait = False
                self.chatTar = random.randint(chatTarL, chatTarH)
                print(self.chatTar + 1)
                break
              if user.id == self.bot.user.id:
                print('Bot reaction ignored')
                #pass
              else:
                print('reaction seen')
                self.Twait = False
                await self.Tmessage.clear_reaction(self.Temoji)
                guildid = user.guild.id
                self.score = addScore(user.id, guildid)
                await self.Tmessage.edit(content=f'**Sparkles have been claimed by <@{user.id}>**', delete_after=7)
                self.Tmessage = None
                self.chatA = 0
                self.chatTar = random.randint(chatTarL, chatTarH)
                print(self.chatTar + 1)
                break
              
    @commands.command(help='Check your score', aliases=['balance', 'sparkles'])
    async def bal(self, ctx, user:discord.Member=None):
      if not user:
        user = ctx.message.author
      guildid = ctx.guild.id
      m = checkScore(user.id, guildid)
      self.Temoji = self.bot.get_emoji(853036933684658176)
      msg = f'__{user.display_name}__ has {m}  {self.Temoji}!'
      embed = Embed(color=Color.green(), title=msg)
      await ctx.reply(embed=embed)

    @commands.command(help='View the leaderboard', aliases=['lb'])
    async def leaderboard(self, ctx):
      await ctx.channel.trigger_typing()
      guildid = ctx.guild.id
      lbid = MakeLb(guildid)
      #print(lbid)
      
      if len(lbid) > 9:
        top10 = lbid[:10]
      else:
        top10 = lbid
      #print(top10)
      self.Temoji = self.bot.get_emoji(853036933684658176)
      def CreateLb(current10, cPos):
        cembed = discord.Embed(color=Color.green(), title=f'{ctx.guild.name} {self.Temoji} Leaderboard:')
        cembed.set_footer(text=f'Requested by: {ctx.author.name}#{ctx.author.discriminator}')
        pos = cPos
        #print(current10)
        for uid in current10:
          print(uid)
          pos+=1
          uscore = checkScore(uid, guildid)
          umember = ctx.guild.get_member(int(uid))
          #print(umember)
          if not umember == None: 
            names = f'{pos}: {umember.name}#{umember.discriminator}'
          else:
            names = f'{pos}: Missing User#0000'
          uscore = f'  {self.Temoji} `{uscore}`'
          cembed.add_field(name=names, value=uscore, inline=False)
        return cembed
      currentpos = 1
      messagel = await ctx.send(embed=CreateLb(top10, 0))
      await ctx.message.delete()
      def check(reaction, user):
        return str(reaction.emoji) == "▶️" or str(reaction.emoji) == "◀️" and user.id == ctx.author.id and reaction.message.id == messagel.id
      while True:
        try:
          await messagel.add_reaction("◀️")
          await messagel.add_reaction("▶️")
          reaction, user = await self.bot.wait_for('reaction_add', timeout=120.0, check=check)
        except TimeoutError:
          break
        if str(reaction.emoji) == "◀️" and user.id == ctx.author.id:
          #move back
          await messagel.remove_reaction("◀️",user)
          #check if maxed out
          if currentpos <= 1:
            pass
          else:
            currentpos-=1 
            #deal with short leaderboards
            if len(lbid) > (currentpos*10):
              current10 = lbid[(currentpos*10-9):]
            #deal with 10 leaderboards
            if len(lbid) > (currentpos*10):
              current10 = lbid[(currentpos*10-9):(currentpos*10)]
            await messagel.edit(embed=CreateLb(current10, ((currentpos*10)-10)))
        if str(reaction.emoji) == "▶️" and user.id == ctx.author.id:
          #move forward
          await messagel.remove_reaction("▶️",user)
          #check if maxed out
          if len(lbid) <= (currentpos*10):
            pass
          else:
            currentpos+=1 
            #deal with short leaderboards
            if len(lbid) > (currentpos*10):
              current10 = lbid[(currentpos*10-9):]
            #deal with 10 leaderboards
            if len(lbid) > (currentpos*10):
              current10 = lbid[(currentpos*10-9):(currentpos*10)]
            await messagel.edit(embed=CreateLb(current10, ((currentpos*10)-10)))
  
    @commands.command(help='Show which channels spawn sparkles!')
    async def sChaList(self, ctx):
      self.Temoji = self.bot.get_emoji(853036933684658176)
      embed = discord.Embed(color=Color.green(), title=f'{self.Temoji} will spawn in these channels:')
      pos = 0
      channelids = ctx.guild.channels
      chaids = []
      for channelid in channelids:
        chaids.append(str(channelid.id))
      #print(chaids)
      self.chatChannels = db['chatChannels']
      for channel in self.chatChannels:
        if str(channel) in chaids:
          pos+=1
          embed.add_field(name=pos, value=f'<#{channel}>', inline=False)
      await ctx.reply(embed=embed)
    
    @commands.command(help='Stop a channel from spawning sparkles, dev only')
    @commands.has_guild_permissions(administrator=True)
    async def sChaRemove(self, ctx, cha):
      self.Temoji = self.bot.get_emoji(853036933684658176)
      i = db['chatChannels']
      print(i)
      if int(cha) in i:
        i.remove(int(cha))
        db['chatChannels'] = i
        self.chatChannels = db['chatChannels']
        await ctx.reply(f'Done. <#{cha}> will no longer spawn {self.Temoji}.')
      else:
        await ctx.reply('That channel was not found')

    @commands.command(help='Start spawning sparkles in a channel, dev only')
    @commands.has_guild_permissions(administrator=True)
    async def sChaAdd(self, ctx, cha):
      self.Temoji = self.bot.get_emoji(853036933684658176)
      i = db['chatChannels']
      if int(cha) not in i:
        i.append(int(cha))
        db['chatChannels'] = i
        self.chatChannels = db['chatChannels']
        await ctx.reply(f'Done. <#{cha}> will now spawn {self.Temoji}.')
      else:
        await ctx.reply('That channel is already spawning sparkles!')
    
    @commands.command(help='Send a backup of the database')
    @commands.check(is_it_me)
    async def sBackup(self, ctx):
      try:
        i = db[f's{guildid}']
      except KeyError:
        db[f's{guildid}'] = {}
      guildid = ctx.guild.id
      i = db[f's{guildid}']
      #i = db['scores']
      embed = discord.Embed(color=Color.green(), title='Current user database', description=str(i))
      await ctx.send(embed=embed)

    @commands.command(help='Fix Sparkles if they aren\'t working, Admin only')
    @commands.has_guild_permissions(administrator=True)
    async def sReClear(self, ctx):
      self.chatA = 0
      self.chatTar = random.randint(chatTarL, chatTarH)
      self.Tmessage = None
      self.Twait = False
      self.chatChannels = db['chatChannels']
      self.Temoji = self.bot.get_emoji(853036933684658176)
      print(self.chatTar + 1)
      await ctx.send('Done. Hope that works!')
    
    @commands.command(help='Reset the sparkle scores, Dev only')
    @commands.check(is_it_me)
    async def sReset(self, ctx):
      guildid = ctx.guild.id
      dev = self.bot.get_user(585991293377839114)
      try:
        i = db[f's{guildid}']
      except KeyError:
        db[f's{guildid}'] = {}
      i = db[f's{guildid}']
      #i = db['scores']
      embed = discord.Embed(color=Color.green(), title='Current user database', description=str(i))
      await dev.send(embed=embed)
      #db['scores'] = {}
      db[f's{guildid}'] = {}
      embed2 = discord.Embed(color=Color.green(), title='Database has been cleared. Its a new dawn!')
      await ctx.send(embed=embed2)
      await ctx.message.delete()

    @commands.command(help='Check bot status, Dev only')
    @commands.check(is_it_me)
    async def sCheck(self, ctx):
      embed = discord.Embed(color=Color.green(), title='Current variable status')
      if self.Temoji:
        self.Temoji=None
      var_list = [self.Twait, self.Tmessage, self.Temoji, self.chatA, self.chatTar]
      i=1
      for var in var_list:
        embed.add_field(name=str(i), value=var)
        i+=1
      await ctx.send(embed=embed)
      

    
def setup(bot):
  bot.add_cog(Sparkle(bot))